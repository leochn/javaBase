package com.vnext.w19juc.juc02;

/**
 * 线程八锁 -- 线程常使用的八种情况
 *
 * @author leo
 * @version 2018/3/28 6:50
 * @since 1.0.0
 */
public class Test05Thread8Monitor {
    /*
     * 题目：判断打印的 "one" or "two" ？
     *
     * 1. 两个普通同步方法，两个线程，标准打印， 打印? //one  two
     * 2. 新增 Thread.sleep() 给 getOne() ,打印? //one  two
     * 3. 新增普通方法 getThree() , 打印? //three  one   two
     * 4. 两个普通同步方法，两个 Number 对象，打印?  //two  one
     * 5. 修改 getOne() 为静态同步方法，打印?  //two   one
     * 6. 修改两个方法均为静态同步方法，一个 Number 对象?  //one   two
     * 7. 一个静态同步方法，一个非静态同步方法，两个 Number 对象?  //two  one
     * 8. 两个静态同步方法，两个 Number 对象?   //one  two
     *
     * 线程八锁的关键：
     * ①非静态方法的锁默认为  this,  静态方法的锁为 对应的 Class 实例
     * ②某一个时刻内，只能有一个线程持有锁，无论几个方法。
     */

    /**
     * 总结：

     ①一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其他的线程都只能等待，换句话说，某一时刻内，只能有唯一一个线程去访问这些synchronized方法。

     ②锁的是当前对象this，被锁定后，其他线程都不能进入到当前对象的其他的synchronized方法。

     ③加个普通方法后发现和同步锁无关。

     ④换成静态同步方法后，情况又变化

     ⑤所有的非静态同步方法用的都是同一把锁 -- 实例对象本身，也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已经取锁的非静态同步方法释放锁就可以获取他们自己的锁。

     ⑥所有的静态同步方法用的也是同一把锁 -- 类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间不会有竞争条件。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们是同一个实例对象
     */

}

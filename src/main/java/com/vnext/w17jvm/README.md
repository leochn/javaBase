## 硬盘上的一个class文件到能够正常执行，在执行之前，需要经过3个步骤：类的加载、连接、初始化
* 加载：查找并加载类的二进制数据
* 连接：
    * 验证：确保被加载的类的正确性
    * 准备：为类的静态变量分配内存，并将其初始化为默认值
    * 解析：把类中的符号引用转换为直接引用
* 初始化：为类的静态变量赋予正确的初始值

## 类加载器的父亲委托机制（Parent Delegation）
    类加载器用来把类加载到Java虚拟机中，从JDK1.2版本开发，类的加载过程采用父亲委托机制，
    这种机制能更好地保证Java平台的安全。在委托机制中，除了Java虚拟机自带的根类加载器以外，
    其余的类加载器都有且只有一个父类加载器。当Java程序请求加载器loader1加载Sample类时，
    loader1首先委托自己的父加载器区加载Sample类，若父加载器能加载，则由父加载器完成加载任务，
    否则才有加载器loader1本身加载Sample类。
    

## 栈
    java栈是一个线程私有的内存空间，一个栈，一般有三部分组成：局部变量表，操作数栈，帧数据区。
    局部变量表：用于报错函数的参数及局部变量。
    操作数栈：主要保存计算过程中间结果，同时作为计算过程中变量临时的存储空间。
    帧数据区：
    
## java方法区


##  垃圾回收的概念和其算法

复制算法：其核心思想就是将内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存留对象复制到未被使用的内存块中去，之后去清楚之前正在使用的内存块中所有的对象，反复去交换两个内存的角色，完成垃圾收集。(java中新生代的from和to空间就是使用这个算法)

标记压缩法：标记压缩法在标记清除法基础之上做了优化，把存活的对象压缩到内存一端，而后进行垃圾清理。(java中老年代使用的就是标记压缩法)

分代算法：就是根据对象的特点把内存分为N块，而后根据每个内存的特点使用不同的算法。

对于新生代和老年代来说，新生代回收频率很高，但是每次回收耗时都很短，而老年代回收频率较低，但是耗时会相对较长，所以应该尽量减少老年代的GC。

分区算法：其主要就是将整个内存分为N多个小的独立空间，每个小空间都可以独立使用，这样细粒度的控制一次回收都少个小空间和那些个小空间，而不是对整个空间进行GC，从而提升性能，并减少GC的停顿时间，

## 垃圾回收是的停顿现象

垃圾回收器的任务是识别和回收垃圾对象进行内存清理，为了让垃圾回收器可以高效的执行，大部分情况下，会要求系统进入一个停顿的状态。停顿的目的是终止所有应用线程，只有这样系统才不会有新的垃圾产生，同时停顿保证了系统状态在某一瞬间的一致性，也有益于更好的标记垃圾对象。因此在垃圾回收时，都会产生应用程序的停顿

## 对象如何进入老年代

一般而言，对象首次创建会被放置在新生代的eden区，如果没有GC介入，则对象不会离开eden区，那么eden区的对象如何进入老年代呢？一般来讲，只要对象的年龄达到一定的大小，就会自动离开年轻代进入老年代，对象年龄是由对象经历数次GC来决定的，在新生代每次GC之后如果对象没有被回收则年龄+1，虚拟机提供了一个参数来控制新生代对象的最大年龄，当超过这个年龄范围就会晋升老年代

-XX:MaxTenuringThreshold，默认情况下为15

总结：根据设置MaxTenuringThreshold参数，可以指定新生代对象经过多少次回收后进入老年代。

另外，大对象(新生代eden区无法装入时，也会直接进入老年代)。JVM里有个参数可以设置对象的大小超过在指定的大小之后，直接晋升老年代。


1.聚合：区域和智能聚合会叠加。

2.在线分析，历史数据显示1小时，单条数据显示。

3.组态：不能用线表示

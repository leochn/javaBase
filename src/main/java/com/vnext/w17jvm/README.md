## 1.类的加载

### 类的加载过程
```
类从被加载到JVM中开始，到卸载为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段.

其中类加载过程包括加载、验证、准备、解析和初始化五个阶段.

在执行之前，需要经过3个步骤：类的加载、连接、初始化：
* 加载：查找并加载类的二进制数据
* 连接：
    * 验证：确保被加载的类的正确性
    * 准备：为类的静态变量分配内存，并将其初始化为默认值
    * 解析：把类中的符号引用转换为直接引用
* 初始化：为类的静态变量赋予正确的初始值
```
### Java程序对类的使用方式可分为两种
– 主动使用
– 被动使用
• 所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才初始化他们

### 主动使用（六种）
    – 创建类的实例
    – 访问某个类或接口的静态变量，或者对该静态变量赋值
    – 调用类的静态方法
    – 反射（如Class.forName("com.example.Test")）
    – 初始化一个类的子类
    – Java虚拟机启动时被标明为启动类的类（JavaTest）

    除了以上六种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化

### 类加载的位置
    类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构.

### 加载.class文件的方式
    – 从本地系统中直接加载
    – 通过网络下载.class文件
    – 从zip， jar等归档文件中加载.class文件
    – 从专有数据库中提取.class文件
    – 将Java源文件动态编译为.class文件

    类的加载的最终产品是位于堆区中的Class对象.
    Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口.

## 2.类的验证

## 3.类的准备

## 4.类的初始化

## 类加载器的父亲委托机制（Parent Delegation）
    类加载器用来把类加载到Java虚拟机中，从JDK1.2版本开发，类的加载过程采用父亲委托机制，
    这种机制能更好地保证Java平台的安全。在委托机制中，除了Java虚拟机自带的根类加载器以外，
    其余的类加载器都有且只有一个父类加载器。当Java程序请求加载器loader1加载Sample类时，
    loader1首先委托自己的父加载器区加载Sample类，若父加载器能加载，则由父加载器完成加载任务，
    否则才有加载器loader1本身加载Sample类。
    

## 栈
    java栈是一个线程私有的内存空间，一个栈，一般有三部分组成：局部变量表，操作数栈，帧数据区。
    局部变量表：用于报错函数的参数及局部变量。
    操作数栈：主要保存计算过程中间结果，同时作为计算过程中变量临时的存储空间。
    帧数据区：
    
## java方法区


##  垃圾回收的概念和其算法

复制算法：其核心思想就是将内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存留对象复制到未被使用的内存块中去，之后去清楚之前正在使用的内存块中所有的对象，反复去交换两个内存的角色，完成垃圾收集。(java中新生代的from和to空间就是使用这个算法)

标记压缩法：标记压缩法在标记清除法基础之上做了优化，把存活的对象压缩到内存一端，而后进行垃圾清理。(java中老年代使用的就是标记压缩法)

分代算法：就是根据对象的特点把内存分为N块，而后根据每个内存的特点使用不同的算法。

对于新生代和老年代来说，新生代回收频率很高，但是每次回收耗时都很短，而老年代回收频率较低，但是耗时会相对较长，所以应该尽量减少老年代的GC。

分区算法：其主要就是将整个内存分为N多个小的独立空间，每个小空间都可以独立使用，这样细粒度的控制一次回收都少个小空间和那些个小空间，而不是对整个空间进行GC，从而提升性能，并减少GC的停顿时间，

## 垃圾回收是的停顿现象

垃圾回收器的任务是识别和回收垃圾对象进行内存清理，为了让垃圾回收器可以高效的执行，大部分情况下，会要求系统进入一个停顿的状态。停顿的目的是终止所有应用线程，只有这样系统才不会有新的垃圾产生，同时停顿保证了系统状态在某一瞬间的一致性，也有益于更好的标记垃圾对象。因此在垃圾回收时，都会产生应用程序的停顿

## 对象如何进入老年代

一般而言，对象首次创建会被放置在新生代的eden区，如果没有GC介入，则对象不会离开eden区，那么eden区的对象如何进入老年代呢？一般来讲，只要对象的年龄达到一定的大小，就会自动离开年轻代进入老年代，对象年龄是由对象经历数次GC来决定的，在新生代每次GC之后如果对象没有被回收则年龄+1，虚拟机提供了一个参数来控制新生代对象的最大年龄，当超过这个年龄范围就会晋升老年代

-XX:MaxTenuringThreshold，默认情况下为15

总结：根据设置MaxTenuringThreshold参数，可以指定新生代对象经过多少次回收后进入老年代。

另外，大对象(新生代eden区无法装入时，也会直接进入老年代)。JVM里有个参数可以设置对象的大小超过在指定的大小之后，直接晋升老年代。


1.聚合：区域和智能聚合会叠加。

2.在线分析，历史数据显示1小时，单条数据显示。

3.组态：不能用线表示
